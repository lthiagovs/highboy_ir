#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "ir_transmitter.h"
#include "ir_protocol.h"
#include "ir_encoder.h"
#include "ir_file.h"

static const char *TAG = "IR_TRANSMIT_MAIN";

// Exemplo de conte√∫do de arquivo .ir (PARSED)
const char* example_ir_parsed = 
"Filetype: IR signals file\n"
"Version: 1\n"
"# Generated by ESP32 IR Receiver\n"
"# \n"
"name: Power_Button\n"
"type: parsed\n"
"protocol: SIRC12\n"
"address: 03 00 00 00\n"
"command: 47 00 00 00\n";

// Exemplo de conte√∫do de arquivo .ir (RAW)
const char* example_ir_raw = 
"Filetype: IR signals file\n"
"Version: 1\n"
"# Generated by ESP32 IR Receiver\n"
"# \n"
"name: Unknown_Signal\n"
"type: raw\n"
"frequency: 38000\n"
"duty_cycle: 0.33\n"
"data: 9000 4500 560 560 560 1690 560 560 560 1690 560 560 560 1690 560 1690 560 560\n";

// Exemplo de m√∫ltiplos sinais (como um arquivo .ir real)
const char* multiple_signals_ir = 
"Filetype: IR signals file\n"
"Version: 1\n"
"# Generated by ESP32 IR Receiver\n"
"# \n"
"name: Power\n"
"type: parsed\n"
"protocol: NEC\n"
"address: 00 00 00 00\n"
"command: 12 00 00 00\n"
"# \n"
"name: Volume_Up\n"
"type: parsed\n"
"protocol: SIRC12\n"
"address: 01 00 00 00\n"
"command: 10 00 00 00\n";

void app_main(void)
{
    ESP_LOGI(TAG, "üöÄ Iniciando transmissor IR com arquivos .ir");
    
    // Inicializar transmissor
    rmt_tx_init();
    
    // Criar encoders
    rmt_encoder_handle_t copy_encoder = NULL;
    rmt_copy_encoder_config_t copy_encoder_config = {};
    esp_err_t err = rmt_new_copy_encoder(&copy_encoder_config, &copy_encoder);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Erro ao criar copy encoder: %s", esp_err_to_name(err));
        return;
    }
    
    ir_encoder_handle_t ir_encoder = NULL;
    ir_encoder_config_t ir_config = IR_ENCODER_DEFAULT_CONFIG();
    err = ir_encoder_new(&ir_config, &ir_encoder);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Erro ao criar IR encoder: %s", esp_err_to_name(err));
        return;
    }
    
    ESP_LOGI(TAG, "‚úÖ Encoders criados com sucesso");
    
    // === EXEMPLO 1: Transmitir sinal PARSED ===
    ESP_LOGI(TAG, "\nüìã === EXEMPLO 1: SINAL PARSED ===");
    
    ir_file_data_t file_data;
    if (ir_file_parse_string(example_ir_parsed, &file_data)) {
        ESP_LOGI(TAG, "üìÑ Arquivo parsed: %s (%s - %s)", 
                 file_data.name, file_data.type, file_data.protocol);
        ESP_LOGI(TAG, "üìä Address: 0x%08lX, Command: 0x%08lX", 
                 (unsigned long)file_data.address, (unsigned long)file_data.command);
        
        // Transmitir
        if (ir_file_transmit(&file_data, ir_encoder)) {
            ESP_LOGI(TAG, "‚úÖ Sinal %s transmitido com sucesso!", file_data.name);
        } else {
            ESP_LOGE(TAG, "‚ùå Falha ao transmitir %s", file_data.name);
        }
        
        ir_file_free_data(&file_data);
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
    
    // === EXEMPLO 2: Transmitir sinal RAW ===
    ESP_LOGI(TAG, "\nüìã === EXEMPLO 2: SINAL RAW ===");
    
    if (ir_file_parse_string(example_ir_raw, &file_data)) {
        ESP_LOGI(TAG, "üìÑ Arquivo RAW: %s (%s)", file_data.name, file_data.type);
        ESP_LOGI(TAG, "üìä Frequ√™ncia: %luHz, Duty: %.2f%%, Dados: %zu valores", 
                 (unsigned long)file_data.frequency, file_data.duty_cycle, file_data.raw_data_count);
        
        // Transmitir
        if (ir_file_transmit(&file_data, ir_encoder)) {
            ESP_LOGI(TAG, "‚úÖ Sinal RAW %s transmitido com sucesso!", file_data.name);
        } else {
            ESP_LOGE(TAG, "‚ùå Falha ao transmitir sinal RAW %s", file_data.name);
        }
        
        ir_file_free_data(&file_data);
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
    
    // === EXEMPLO 3: Processar m√∫ltiplos sinais (simula√ß√£o) ===
    ESP_LOGI(TAG, "\nüìã === EXEMPLO 3: M√öLTIPLOS SINAIS ===");
    
    // Simula leitura de um arquivo com m√∫ltiplos sinais
    // Em uma implementa√ß√£o real, voc√™ faria o parsing linha por linha
    // ou dividiria o conte√∫do por se√ß√µes
    
    const char* signals[] = {
        "name: TV_Power\ntype: parsed\nprotocol: NEC\naddress: 10 00 00 00\ncommand: 01 00 00 00\n",
        "name: TV_VolumeUp\ntype: parsed\nprotocol: NEC\naddress: 10 00 00 00\ncommand: 02 00 00 00\n",
        "name: TV_VolumeDown\ntype: parsed\nprotocol: NEC\naddress: 10 00 00 00\ncommand: 03 00 00 00\n"
    };
    
    for (int i = 0; i < 3; i++) {
        // Adiciona cabe√ßalho padr√£o
        char full_signal[512];
        snprintf(full_signal, sizeof(full_signal), 
                "Filetype: IR signals file\nVersion: 1\n# Test\n# \n%s", signals[i]);
        
        if (ir_file_parse_string(full_signal, &file_data)) {
            ESP_LOGI(TAG, "üì∫ Transmitindo: %s", file_data.name);
            
            if (ir_file_transmit(&file_data, ir_encoder)) {
                ESP_LOGI(TAG, "‚úÖ %s OK", file_data.name);
            } else {
                ESP_LOGE(TAG, "‚ùå %s FALHOU", file_data.name);
            }
            
            ir_file_free_data(&file_data);
            vTaskDelay(pdMS_TO_TICKS(1000));
        }
    }
    
    // === EXEMPLO 4: Loop de transmiss√£o cont√≠nua ===
    ESP_LOGI(TAG, "\nüìã === EXEMPLO 4: LOOP CONT√çNUO ===");
    
    // Simula transmiss√£o cont√≠nua de um controle remoto
    for (int cycle = 0; cycle < 3; cycle++) {
        ESP_LOGI(TAG, "üîÑ Ciclo %d de transmiss√£o", cycle + 1);
        
        // Bot√£o Power
        char power_signal[256];
        snprintf(power_signal, sizeof(power_signal),
                "Filetype: IR signals file\nVersion: 1\n# \n"
                "name: Power_%d\ntype: parsed\nprotocol: NEC\n"
                "address: FF 00 00 00\ncommand: %02X 00 00 00\n", 
                cycle, 0x10 + cycle);
        
        if (ir_file_parse_string(power_signal, &file_data)) {
            ESP_LOGI(TAG, "üî¥ Enviando %s", file_data.name);
            ir_file_transmit(&file_data, ir_encoder);
            ir_file_free_data(&file_data);
        }
        
        vTaskDelay(pdMS_TO_TICKS(3000));
    }
    
    // Cleanup
    ESP_LOGI(TAG, "üßπ Limpando recursos...");
    ir_encoder_del(ir_encoder);
    rmt_del_encoder(copy_encoder);
    rmt_tx_delete();
    
    ESP_LOGI(TAG, "üèÅ Transmiss√£o IR via arquivos .ir conclu√≠da!");
    
    // Loop infinito para manter a task viva
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(10000));
    }
}