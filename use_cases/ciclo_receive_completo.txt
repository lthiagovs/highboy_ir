#include <stdio.h>
#include <string.h>
#include <time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "ir_receiver.h"
#include "ir_protocol.h"
#include "ir_path.h"

#define TAG "MAIN"

static rmt_symbol_word_t raw_symbols[MEM_BLOCK_SYMBOLS];

// Estrutura para dados decodificados
typedef struct {
    char protocol[32];
    uint32_t address;
    uint32_t command;
} ir_decoded_data_t;

// Fun√ß√£o para gerar o conte√∫do do arquivo .ir
char* generate_ir_file_content(const char* signal_name, const ir_decoded_data_t* decoded) {
    static char buffer[1024];
    
    snprintf(buffer, sizeof(buffer),
        "Filetype: IR signals file\n"
        "Version: 1\n"
        "# Generated by HIGHBOY\n"
        "# \n"
        "name: %s\n"
        "type: parsed\n"
        "protocol: %s\n"
        "address: %02lX %02lX %02lX %02lX\n"
        "command: %02lX %02lX %02lX %02lX\n",
        signal_name,
        decoded->protocol,
        // Endere√ßo formatado em 4 bytes
        (unsigned long)(decoded->address & 0xFF),
        (unsigned long)((decoded->address >> 8) & 0xFF),
        (unsigned long)((decoded->address >> 16) & 0xFF),
        (unsigned long)((decoded->address >> 24) & 0xFF),
        // Comando formatado em 4 bytes
        (unsigned long)(decoded->command & 0xFF),
        (unsigned long)((decoded->command >> 8) & 0xFF),
        (unsigned long)((decoded->command >> 16) & 0xFF),
        (unsigned long)((decoded->command >> 24) & 0xFF)
    );
    
    return buffer;
}

// Fun√ß√£o para decodificar Sony SIRC
uint32_t decode_sony_sirc(rmt_symbol_word_t* symbols, size_t count) {
    uint32_t data = 0;
    
    // Pula o header (primeiro s√≠mbolo)
    for (size_t i = 1; i < count; i++) {
        uint32_t mark_time = symbols[i].duration0;
        
        // Sony SIRC: 600us = '0', 1200us = '1' (aproximadamente)
        if (mark_time > 900) {  // > 900us consideramos '1'
            data |= (1 << (i - 1));
        }
        // Se <= 900us, consideramos '0' (n√£o precisa setar)
    }
    
    return data;
}

// Fun√ß√£o para decodificar RC6
uint32_t decode_rc6(rmt_symbol_word_t* symbols, size_t count) {
    uint32_t data = 0;
    
    // RC6 tem codifica√ß√£o Manchester
    // An√°lise b√°sica dos tempos
    for (size_t i = 1; i < count; i++) {
        uint32_t mark_time = symbols[i].duration0;
        uint32_t space_time = symbols[i].duration1;
        
        // L√≥gica simples baseada na dura√ß√£o do mark
        if (mark_time > 600) {  // Bit '1'
            data |= (1 << (i - 1));
        }
        // Se <= 600us, consideramos '0'
    }
    
    return data;
}

// Fun√ß√£o para decodificar dados do protocolo
void decode_protocol_data(const char* protocol, rmt_symbol_word_t* symbols, size_t count, ir_decoded_data_t* decoded) {
    // Copia o nome do protocolo
    strncpy(decoded->protocol, protocol, sizeof(decoded->protocol) - 1);
    decoded->protocol[sizeof(decoded->protocol) - 1] = '\0';
    
    // Decodifica baseado no protocolo
    if (strcmp(protocol, "NEC") == 0) {
        uint32_t data = decode_nec_data(symbols, count);
        
        // Para NEC, extrai address e command dos 32 bits
        decoded->address = (data >> 16) & 0xFFFF;  // 16 bits superiores
        decoded->command = data & 0xFFFF;          // 16 bits inferiores
        
        ESP_LOGI(TAG, "NEC - Address: 0x%04X, Command: 0x%04X", 
                 (unsigned int)decoded->address, (unsigned int)decoded->command);
                 
    } else if (strcmp(protocol, "RC5") == 0) {
        // Implementar decodifica√ß√£o RC5 se necess√°rio
        decoded->address = 0x0000;  // Placeholder
        decoded->command = 0x0000;  // Placeholder
        ESP_LOGI(TAG, "RC5 - Decodifica√ß√£o n√£o implementada ainda");
        
    } else if (strcmp(protocol, "SONY") == 0 || strcmp(protocol, "SIRC") == 0) {
        uint32_t data = decode_sony_sirc(symbols, count);
        
        // Sony SIRC: 7 bits = comando, 5 bits = endere√ßo (formato 12 bits)
        // ou 7 bits = comando, 8 bits = endere√ßo (formato 15 bits)
        decoded->command = data & 0x7F;         // 7 bits de comando
        decoded->address = (data >> 7) & 0x1F;  // 5 bits de endere√ßo
        
        ESP_LOGI(TAG, "SONY/SIRC - Raw: 0x%08X, Address: 0x%02X, Command: 0x%02X", 
                 (unsigned int)data, (unsigned int)decoded->address, (unsigned int)decoded->command);
                 
    } else if (strcmp(protocol, "RC6") == 0) {
        uint32_t data = decode_rc6(symbols, count);
        
        // RC6: estrutura varia, mas geralmente 8 bits endere√ßo + 8 bits comando
        decoded->address = (data >> 8) & 0xFF;  // 8 bits superiores
        decoded->command = data & 0xFF;         // 8 bits inferiores
        
        ESP_LOGI(TAG, "RC6 - Raw: 0x%08X, Address: 0x%02X, Command: 0x%02X", 
                 (unsigned int)data, (unsigned int)decoded->address, (unsigned int)decoded->command);
        
    } else {
        // Protocolo desconhecido - tenta decodifica√ß√£o gen√©rica
        uint32_t data = 0;
        
        // An√°lise gen√©rica baseada nos tempos
        for (size_t i = 1; i < count && i < 32; i++) {
            uint32_t mark_time = symbols[i].duration0;
            
            if (mark_time > 700) {  // Threshold gen√©rico
                data |= (1 << (i - 1));
            }
        }
        
        decoded->address = (data >> 8) & 0xFF;
        decoded->command = data & 0xFF;
        
        ESP_LOGI(TAG, "Protocolo desconhecido (%s) - Raw: 0x%08X, Address: 0x%02X, Command: 0x%02X", 
                 protocol, (unsigned int)data, (unsigned int)decoded->address, (unsigned int)decoded->command);
    }
}

// Fun√ß√£o para gerar nome do arquivo baseado no timestamp
void generate_filename(char* filename, size_t size, const char* protocol) {
    // Usa tick count como timestamp simples
    uint32_t timestamp = xTaskGetTickCount();
    snprintf(filename, size, "%s_%lu.ir", protocol, (unsigned long)timestamp);
}

void app_main(void)
{
    ESP_LOGI(TAG, "Inicializando receptor IR...");

    // Inicializa o m√≥dulo
    if (ir_path_init() != IR_PATH_OK) {
        ESP_LOGE("MAIN", "Failed to initialize SD card");
        return;
    }

    if (!rmt_rx_init()) {
        ESP_LOGE(TAG, "Erro na inicializa√ß√£o do receptor IR");
        return;
    }

    if (!rmt_rx_receive_start_queue()) {
        ESP_LOGE(TAG, "Falha ao criar fila de recep√ß√£o");
        return;
    }

    size_t received = 0;

    if (rmt_rx_receive_once(raw_symbols, MEM_BLOCK_SYMBOLS, &received)) {
        ESP_LOGI(TAG, "Recebido %d s√≠mbolos IR", (int)received);
        
        // DETEC√á√ÉO DO PROTOCOLO
        const char* protocol = detect_ir_protocol(raw_symbols, received);
        ESP_LOGI(TAG, "üéØ PROTOCOLO DETECTADO: %s", protocol);
        
        // AN√ÅLISE DETALHADA
        analyze_your_signal(raw_symbols, received);
        
        // DECODIFICA√á√ÉO DOS DADOS
        ir_decoded_data_t decoded_data;
        decode_protocol_data(protocol, raw_symbols, received, &decoded_data);
        
        // Mostra primeiros s√≠mbolos (debug)
        for (size_t i = 0; i < received && i < 10; i++) {
            ESP_LOGI(TAG, "Simb[%d] L0=%d D0=%dus L1=%d D1=%dus", (int)i,
                     raw_symbols[i].level0, raw_symbols[i].duration0,
                     raw_symbols[i].level1, raw_symbols[i].duration1);
        }
        
        // GERA√á√ÉO DO ARQUIVO .IR
        char filename[64];
        generate_filename(filename, sizeof(filename), protocol);
        
        // Gera nome do sinal baseado no protocolo e dados
        char signal_name[64];
        snprintf(signal_name, sizeof(signal_name), "%s_Signal_%04X_%04X", 
                 protocol, 
                 (unsigned int)decoded_data.address, 
                 (unsigned int)decoded_data.command);
        
        // Gera conte√∫do do arquivo
        char* file_content = generate_ir_file_content(signal_name, &decoded_data);
        
        // Salva o arquivo
        ESP_LOGI(TAG, "üíæ Salvando arquivo: %s", filename);
        if (ir_path_write_file(filename, file_content, false) == IR_PATH_OK) {
            ESP_LOGI(TAG, "‚úÖ Arquivo .ir salvo com sucesso!");
            ESP_LOGI(TAG, "üìÑ Nome do sinal: %s", signal_name);
            ESP_LOGI(TAG, "üìÑ Protocolo: %s", decoded_data.protocol);
            ESP_LOGI(TAG, "üìÑ Endere√ßo: 0x%08X", (unsigned int)decoded_data.address);
            ESP_LOGI(TAG, "üìÑ Comando: 0x%08X", (unsigned int)decoded_data.command);
            
            // VERIFICA√á√ÉO: L√™ o arquivo salvo para confirmar
            ESP_LOGI(TAG, "üîç Verificando arquivo salvo...");
            char read_buffer[1024];
            
            if (ir_path_read_file(filename, read_buffer, sizeof(read_buffer)) == IR_PATH_OK) {
                ESP_LOGI(TAG, "‚úÖ Arquivo lido com sucesso!");
                ESP_LOGI(TAG, "üìñ === CONTE√öDO LIDO DO ARQUIVO ===");
                printf("%s", read_buffer);
                ESP_LOGI(TAG, "üìñ === FIM DO ARQUIVO LIDO ===");
                
                // Verifica se o conte√∫do lido √© igual ao escrito
                if (strcmp(file_content, read_buffer) == 0) {
                    ESP_LOGI(TAG, "‚úÖ Verifica√ß√£o OK: Conte√∫do escrito = Conte√∫do lido");
                } else {
                    ESP_LOGW(TAG, "‚ö†Ô∏è Diferen√ßa detectada entre escrito e lido!");
                    ESP_LOGW(TAG, "Tamanho escrito: %d, Tamanho lido: %d", 
                             strlen(file_content), strlen(read_buffer));
                }
            } else {
                ESP_LOGE(TAG, "‚ùå Erro ao ler arquivo para verifica√ß√£o");
            }
            
        } else {
            ESP_LOGE(TAG, "‚ùå Erro ao salvar arquivo .ir");
        }
        
    } else {
        ESP_LOGW(TAG, "Timeout - nenhum sinal recebido");
    }

    rmt_rx_receive_stop_queue();
    rmt_rx_delete();
    ESP_LOGI(TAG, "Receptor IR finalizado.");
}