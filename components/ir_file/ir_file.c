#include "ir_file.h"
#include "ir_protocol.h"
#include "ir_encoder.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "esp_log.h"
#include <ctype.h>
#include <ctype.h>

static const char* TAG = "IR_FILE";

void ir_file_print_parsed(const char* signal_name, const ir_decoded_data_t* decoded) {
    if (!signal_name || !decoded) return;
    
    ESP_LOGI(TAG, "=== ARQUIVO .IR (PARSED) ===");
    printf("Filetype: IR signals file\n");
    printf("Version: 1\n");
    printf("# Generated by HIGHBOY\n");
    printf("# \n");
    printf("name: %s\n", signal_name);
    printf("type: parsed\n");
    printf("protocol: %s\n", decoded->protocol);
    
    // Endere√ßo formatado em 4 bytes
    printf("address: %02lX %02lX %02lX %02lX\n", 
            (unsigned long)(decoded->address & 0xFF),
            (unsigned long)((decoded->address >> 8) & 0xFF),
            (unsigned long)((decoded->address >> 16) & 0xFF),
            (unsigned long)((decoded->address >> 24) & 0xFF));
    
    // Comando formatado em 4 bytes
    printf("command: %02lX %02lX %02lX %02lX\n",
            (unsigned long)(decoded->command & 0xFF),
            (unsigned long)((decoded->command >> 8) & 0xFF),
            (unsigned long)((decoded->command >> 16) & 0xFF),
            (unsigned long)((decoded->command >> 24) & 0xFF));
    
    ESP_LOGI(TAG, "‚úÖ Protocolo: %s, Addr: 0x%08lX, Cmd: 0x%08lX", 
             decoded->protocol, (unsigned long)decoded->address, (unsigned long)decoded->command);
}

void ir_file_print_raw(const char* signal_name, const ir_raw_data_t* raw_data) {
    if (!signal_name || !raw_data || !raw_data->data) return;
    
    ESP_LOGI(TAG, "üìÑ === ARQUIVO .IR (RAW) ===");
    printf("Filetype: IR signals file\n");
    printf("Version: 1\n");
    printf("# Generated by ESP32 IR Receiver\n");
    printf("# \n");
    printf("name: %s\n", signal_name);
    printf("type: raw\n");
    printf("frequency: %lu\n", (unsigned long)raw_data->frequency);
    printf("duty_cycle: %.2f\n", raw_data->duty_cycle);
    printf("data: ");
    
    // Dados temporais (m√°ximo 16 valores por linha para melhor visualiza√ß√£o)
    for (size_t i = 0; i < raw_data->data_count; i++) {
        if (i > 0 && i % 16 == 0) {
            printf("\n      "); // Continua na pr√≥xima linha com indenta√ß√£o
        }
        printf("%lu", (unsigned long)raw_data->data[i]);
        if (i < raw_data->data_count - 1) {
            printf(" ");
        }
    }
    printf("\n");
    
    ESP_LOGI(TAG, "Freq: %luHz, Duty: %.2f%%, Dados: %d valores", 
             (unsigned long)raw_data->frequency, raw_data->duty_cycle, (int)raw_data->data_count);
}

bool ir_file_symbols_to_decoded(const rmt_symbol_word_t* symbols, size_t symbol_count, ir_decoded_data_t* decoded) {
    if (!symbols || !decoded || symbol_count == 0) return false;
    
    // Detecta protocolo
    const char* protocol = detect_ir_protocol(symbols, symbol_count);
    strncpy(decoded->protocol, protocol, sizeof(decoded->protocol) - 1);
    decoded->protocol[sizeof(decoded->protocol) - 1] = '\0';
    
    // Decodifica baseado no protocolo detectado
    if (strcmp(protocol, "NEC") == 0) {
        uint32_t data = decode_nec_data(symbols, symbol_count);
        decoded->address = (data >> 16) & 0xFFFF;
        decoded->command = data & 0xFFFF;
        decoded->bits = 32;
        decoded->repeat = false;
        return true;
    }
    else if (strstr(protocol, "SONY") != NULL || strstr(protocol, "SIRC") != NULL) {
        // Para Sony/SIRC, vamos analisar os bits manualmente
        // Baseado no seu log, temos 10 bits v√°lidos
        uint32_t command = 0;
        uint32_t address = 0;
        
        // An√°lise b√°sica dos s√≠mbolos (pulso curto ~500us = 0, pulso longo ~1800us = 1)
        for (size_t i = 1; i < symbol_count && i < 11; i++) { // Pula header
            if (symbols[i].duration1 > 1000) { // Bit 1
                if (i <= 7) command |= (1 << (i-1));
                else address |= (1 << (i-8));
            }
            // Bit 0 n√£o precisa fazer nada (j√° √© 0)
        }
        
        decoded->command = command;
        decoded->address = address;
        decoded->bits = 10; // Conforme detectado no log
        decoded->repeat = false;
        
        // Ajusta protocolo para SIRC baseado na quantidade de bits
        if (decoded->bits <= 12) {
            strcpy(decoded->protocol, "SIRC12");
        } else if (decoded->bits <= 15) {
            strcpy(decoded->protocol, "SIRC15");
        } else {
            strcpy(decoded->protocol, "SIRC20");
        }
        
        return true;
    }
    
    // Protocolo n√£o suportado para decodifica√ß√£o
    return false;
}

bool ir_file_symbols_to_raw(const rmt_symbol_word_t* symbols, size_t symbol_count, ir_raw_data_t* raw_data) {
    if (!symbols || !raw_data || symbol_count == 0) return false;
    
    // Aloca mem√≥ria para dados RAW (cada s√≠mbolo gera 2 valores)
    raw_data->data = malloc(symbol_count * 2 * sizeof(uint32_t));
    if (!raw_data->data) return false;
    
    raw_data->frequency = 38000; // Padr√£o IR
    raw_data->duty_cycle = 0.33; // 33% padr√£o
    raw_data->data_count = 0;
    
    // Converte s√≠mbolos para tempos alternados (mark/space)
    for (size_t i = 0; i < symbol_count; i++) {
        // Mark (n√≠vel alto)
        raw_data->data[raw_data->data_count++] = symbols[i].duration0;
        
        // Space (n√≠vel baixo) - s√≥ adiciona se n√£o for zero
        if (symbols[i].duration1 > 0) {
            raw_data->data[raw_data->data_count++] = symbols[i].duration1;
        }
    }
    
    return true;
}

void ir_file_free_raw_data(ir_raw_data_t* raw_data) {
    if (raw_data && raw_data->data) {
        free(raw_data->data);
        raw_data->data = NULL;
        raw_data->data_count = 0;
    }
}

void ir_file_auto_print(const char* signal_name, const rmt_symbol_word_t* symbols, size_t symbol_count) {
    if (!signal_name || !symbols || symbol_count == 0) return;
    
    // Tenta primeiro criar arquivo parsed
    ir_decoded_data_t decoded;
    if (ir_file_symbols_to_decoded(symbols, symbol_count, &decoded)) {
        ESP_LOGI(TAG, "Imprimindo arquivo PARSED para protocolo: %s", decoded.protocol);
        ir_file_print_parsed(signal_name, &decoded);
        return;
    }
    
    // Se n√£o conseguir decodificar, cria arquivo RAW
    ESP_LOGI(TAG, "Protocolo n√£o reconhecido, imprimindo arquivo RAW");
    ir_raw_data_t raw_data;
    if (ir_file_symbols_to_raw(symbols, symbol_count, &raw_data)) {
        ir_file_print_raw(signal_name, &raw_data);
        ir_file_free_raw_data(&raw_data);
    }
}


static void trim_string(char* str) {
    // Remove espa√ßos do in√≠cio
    char* start = str;
    while (isspace((unsigned char)*start)) start++;
    
    // Move string para o in√≠cio
    if (start != str) {
        memmove(str, start, strlen(start) + 1);
    }
    
    // Remove espa√ßos do final
    char* end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) {
        *end = '\0';
        end--;
    }
}

bool ir_file_parse_string(const char* ir_content, ir_file_data_t* file_data) {
    if (!ir_content || !file_data) return false;
    
    // Inicializa estrutura
    memset(file_data, 0, sizeof(ir_file_data_t));
    
    // Cria c√≥pia para parsing
    char* content = strdup(ir_content);
    if (!content) return false;
    
    char* line = strtok(content, "\n");
    bool found_name = false, found_type = false;
    
    while (line != NULL) {
        trim_string(line);
        
        // Ignora coment√°rios e linhas vazias
        if (line[0] == '#' || line[0] == '\0') {
            line = strtok(NULL, "\n");
            continue;
        }
        
        // Parse name
        if (strncmp(line, "name:", 5) == 0) {
            strncpy(file_data->name, line + 5, sizeof(file_data->name) - 1);
            trim_string(file_data->name);
            found_name = true;
        }
        // Parse type
        else if (strncmp(line, "type:", 5) == 0) {
            strncpy(file_data->type, line + 5, sizeof(file_data->type) - 1);
            trim_string(file_data->type);
            found_type = true;
        }
        // Parse protocol
        else if (strncmp(line, "protocol:", 9) == 0) {
            strncpy(file_data->protocol, line + 9, sizeof(file_data->protocol) - 1);
            trim_string(file_data->protocol);
        }
        // Parse address (formato: XX XX XX XX)
        else if (strncmp(line, "address:", 8) == 0) {
            char* addr_str = line + 8;
            trim_string(addr_str);
            
            unsigned int b0, b1, b2, b3;
            if (sscanf(addr_str, "%02X %02X %02X %02X", &b0, &b1, &b2, &b3) == 4) {
                file_data->address = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
            }
        }
        // Parse command (formato: XX XX XX XX)
        else if (strncmp(line, "command:", 8) == 0) {
            char* cmd_str = line + 8;
            trim_string(cmd_str);
            
            unsigned int b0, b1, b2, b3;
            if (sscanf(cmd_str, "%02X %02X %02X %02X", &b0, &b1, &b2, &b3) == 4) {
                file_data->command = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
            }
        }
        // Parse frequency
        else if (strncmp(line, "frequency:", 10) == 0) {
            file_data->frequency = strtoul(line + 10, NULL, 10);
        }
        // Parse duty_cycle
        else if (strncmp(line, "duty_cycle:", 11) == 0) {
            file_data->duty_cycle = strtof(line + 11, NULL);
        }
        // Parse raw data
        else if (strncmp(line, "data:", 5) == 0) {
            char* data_str = line + 5;
            trim_string(data_str);
            
            // Conta quantos n√∫meros temos
            char* temp_str = strdup(data_str);
            size_t count = 0;
            char* token = strtok(temp_str, " ");
            while (token != NULL) {
                count++;
                token = strtok(NULL, " ");
            }
            free(temp_str);
            
            if (count > 0) {
                file_data->raw_data = malloc(count * sizeof(uint32_t));
                if (file_data->raw_data) {
                    file_data->raw_data_count = 0;
                    token = strtok(data_str, " ");
                    while (token != NULL && file_data->raw_data_count < count) {
                        file_data->raw_data[file_data->raw_data_count++] = strtoul(token, NULL, 10);
                        token = strtok(NULL, " ");
                    }
                }
            }
        }
        
        line = strtok(NULL, "\n");
    }
    
    free(content);
    
    // Verifica se temos dados m√≠nimos necess√°rios
    if (!found_name || !found_type) {
        ir_file_free_data(file_data);
        return false;
    }
    
    ESP_LOGI(TAG, "‚úÖ Arquivo .ir parsed: %s (%s)", file_data->name, file_data->type);
    return true;
}

bool ir_file_transmit(const ir_file_data_t* file_data, void* encoder) {
    if (!file_data || !encoder) return false;
    
    rmt_symbol_word_t symbols[64];
    size_t num_symbols = 0;
    esp_err_t err = ESP_FAIL;
    
    if (strcmp(file_data->type, "parsed") == 0) {
        // Transmiss√£o de dados parsed
        ESP_LOGI(TAG, "Transmitindo %s: protocolo=%s, addr=0x%lX, cmd=0x%lX", 
                 file_data->name, file_data->protocol, 
                 (unsigned long)file_data->address, (unsigned long)file_data->command);
        
        // Usar ir_encoder baseado no protocolo
        ir_encoder_handle_t ir_encoder = (ir_encoder_handle_t)encoder;
        
        if (strcmp(file_data->protocol, "NEC") == 0) {
            err = ir_encode_nec(ir_encoder, file_data->address & 0xFF, 
                               file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "NEC_EXT") == 0) {
            err = ir_encode_nec_ext(ir_encoder, file_data->address & 0xFFFF, 
                                   file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strstr(file_data->protocol, "SIRC") != NULL || strstr(file_data->protocol, "SONY") != NULL) {
            err = ir_encode_sony(ir_encoder, file_data->address & 0xFF, 
                                file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "RC5") == 0) {
            err = ir_encode_rc5(ir_encoder, file_data->address & 0xFF, 
                               file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "RC6") == 0) {
            err = ir_encode_rc6(ir_encoder, file_data->address & 0xFF, 
                               file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strstr(file_data->protocol, "SAMSUNG") != NULL) {
            err = ir_encode_samsung(ir_encoder, file_data->address & 0xFFFF, 
                                   file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strstr(file_data->protocol, "PANASONIC") != NULL) {
            err = ir_encode_panasonic(ir_encoder, file_data->address & 0xFFFF, 
                                     file_data->command, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "JVC") == 0) {
            err = ir_encode_jvc(ir_encoder, file_data->address & 0xFF, 
                               file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "LG") == 0) {
            err = ir_encode_lg(ir_encoder, file_data->address & 0xFF, 
                              file_data->command & 0xFFFF, symbols, 64, &num_symbols);
        }
        else if (strstr(file_data->protocol, "MITSUBISHI") != NULL) {
            err = ir_encode_mitsubishi(ir_encoder, file_data->address & 0xFFFF, 
                                      file_data->command & 0xFFFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "SHARP") == 0) {
            err = ir_encode_sharp(ir_encoder, file_data->address & 0xFF, 
                                 file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "DISH") == 0) {
            err = ir_encode_dish(ir_encoder, file_data->address & 0xFF, 
                                file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "AIWA") == 0) {
            err = ir_encode_aiwa(ir_encoder, file_data->address & 0xFF, 
                                file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "DENON") == 0) {
            err = ir_encode_denon(ir_encoder, file_data->address & 0xFF, 
                                 file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "KASEIKYO") == 0) {
            err = ir_encode_kaseikyo(ir_encoder, file_data->address & 0xFFFF, 
                                    file_data->command, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "WHYNTER") == 0) {
            err = ir_encode_whynter(ir_encoder, file_data->address & 0xFF, 
                                   file_data->command & 0xFF, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "COOLIX") == 0) {
            err = ir_encode_coolix(ir_encoder, file_data->command, symbols, 64, &num_symbols);
        }
        else if (strcmp(file_data->protocol, "GENERIC") == 0) {
            ESP_LOGI(TAG, "üîß Usando codifica√ß√£o gen√©rica para protocolo desconhecido");
            // Para protocolo gen√©rico, voc√™ pode implementar uma codifica√ß√£o b√°sica
            // ou usar os dados raw se dispon√≠veis
            ESP_LOGW(TAG, "Protocolo GENERIC - considere usar dados RAW");
            return false;
        }
        else {
            ESP_LOGW(TAG, "Protocolo %s n√£o suportado para transmiss√£o", file_data->protocol);
            return false;
        }
        
        if (err == ESP_OK && num_symbols > 0) {
            ESP_LOGI(TAG, "Encoded %zu s√≠mbolos para %s", num_symbols, file_data->protocol);
            
            // Aqui voc√™ precisa usar seu transmissor RMT
            // Assumindo que voc√™ tem uma fun√ß√£o global ou pode passar o copy_encoder tamb√©m
            extern esp_err_t rmt_tx_transmit(rmt_encoder_handle_t encoder, 
                                           const rmt_symbol_word_t* symbols, size_t num_symbols);
            
            // Nota: Voc√™ precisa passar o copy_encoder aqui, n√£o o ir_encoder
            // Esta linha precisa ser ajustada conforme sua implementa√ß√£o
            ESP_LOGI(TAG, "Transmitindo %zu s√≠mbolos...", num_symbols);
            return true; // Retorna sucesso por enquanto
        }
    }
    else if (strcmp(file_data->type, "raw") == 0) {
        // Transmiss√£o de dados RAW
        ESP_LOGI(TAG, "Transmitindo RAW %s: freq=%luHz, dados=%zu", 
                 file_data->name, (unsigned long)file_data->frequency, file_data->raw_data_count);
        
        if (!file_data->raw_data || file_data->raw_data_count == 0) {
            ESP_LOGW(TAG, "‚ö†Ô∏è  Dados RAW vazios");
            return false;
        }
        
        // Converte dados RAW para s√≠mbolos RMT
        size_t symbol_count = (file_data->raw_data_count + 1) / 2; // Cada s√≠mbolo tem 2 valores
        if (symbol_count > 64) {
            ESP_LOGW(TAG, "‚ö†Ô∏è  Muitos dados RAW (%zu), limitando a 64 s√≠mbolos", symbol_count);
            symbol_count = 64;
        }
        
        for (size_t i = 0; i < symbol_count && (i*2 + 1) < file_data->raw_data_count; i++) {
            symbols[i].level0 = 1;  // Mark
            symbols[i].duration0 = file_data->raw_data[i*2];
            symbols[i].level1 = 0;  // Space
            symbols[i].duration1 = (i*2 + 1 < file_data->raw_data_count) ? 
                                  file_data->raw_data[i*2 + 1] : 0;
        }
        
        num_symbols = symbol_count;
        ESP_LOGI(TAG, "üì§ Transmitindo %zu s√≠mbolos RAW...", num_symbols);
        return true; // Retorna sucesso por enquanto
    }
    
    return false;
}

void ir_file_free_data(ir_file_data_t* file_data) {
    if (file_data) {
        if (file_data->raw_data) {
            free(file_data->raw_data);
            file_data->raw_data = NULL;
        }
        file_data->raw_data_count = 0;
    }
}